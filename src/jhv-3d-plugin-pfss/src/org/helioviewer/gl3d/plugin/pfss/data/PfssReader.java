package org.helioviewer.gl3d.plugin.pfss.data;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;

import org.helioviewer.gl3d.scenegraph.math.GL3DVec3f;
import org.helioviewer.gl3d.wcs.CoordinateVector;

/**
 * New PFSS File importer. It can read files that are generated by the
 * resources/idl/conversion/pfss_field_export.pro IDL Script.
 * 
 * @author Simon Spoerri (simon.spoerri@fhnw.ch)
 * 
 */
public class PfssReader {

    public PfssDimension readFile(String filename) throws IOException, IncorrectPfssFileException {

        FileReader filereader = new FileReader(filename);
        BufferedReader reader = new BufferedReader(filereader);

        String line;

        // Read timestamp
        line = reader.readLine();
        if (!line.startsWith("timestamp")) {
            throw new IncorrectPfssFileException(null);
        }
        line = reader.readLine();
        if (!line.startsWith("B0")) {
            throw new IncorrectPfssFileException(null);
        }
        double b0 = Math.toRadians(Double.parseDouble(line.substring(line.trim().indexOf(':') + 1).trim()));
        // b0 = Math.PI/2-b0;

        line = reader.readLine();
        if (!line.startsWith("L0")) {
            throw new IncorrectPfssFileException(null);
        }
        double l0 = Math.toRadians(Double.parseDouble(line.substring(line.trim().indexOf(':') + 1).trim()));

        PfssDimension result = new PfssDimension(b0, l0);

        // double minColatitude = Double.NaN;
        // double maxColatitude = Double.NaN;
        // double minPhi = Double.NaN;
        // double maxPhi = Double.NaN;

        line = reader.readLine();
        if (line.startsWith("---")) {
            // Start with the lines
            while (!((line = reader.readLine()) == null)) {
                PfssCurve curve = new PfssCurve();
                line = line.trim();
                int open = Integer.parseInt(line);
                GL3DVec3f color = null;
                switch (open) {
                case -1:
                    color = new GL3DVec3f(1, 0, 0);
                    break;
                case 0:
                    color = new GL3DVec3f(1, 1, 1);
                    break;
                case 1:
                    color = new GL3DVec3f(0, 1, 0);
                    break;
                default:
                    throw new IncorrectPfssFileException(null);
                }
                curve.color = color;
                // Read the delimiter
                line = reader.readLine();
                if (line != null && line.startsWith("-")) {
                    while (!((line = reader.readLine()) == null)) {
                        // move to the next curve
                        if (line.equals("--")) {
                            break;
                        }

                        // extract point coordinates
                        ArrayList<String> coords = new ArrayList<String>(Arrays.asList(line.split(" ")));
                        for (Iterator<String> iter = coords.iterator(); iter.hasNext();) {
                            String val = iter.next();
                            if (val.equals(""))
                                iter.remove();
                        }
                        double r = Double.parseDouble(coords.get(0));
                        double colatitude = Double.parseDouble(coords.get(1));
                        double phi = Double.parseDouble(coords.get(2));

                        // minColatitude = (Double.isNaN(minColatitude) ||
                        // colatitude<minColatitude)?colatitude:minColatitude;
                        // maxColatitude = (Double.isNaN(maxColatitude) ||
                        // colatitude>maxColatitude)?colatitude:maxColatitude;
                        // minPhi = (Double.isNaN(minPhi) ||
                        // phi<minPhi)?phi:minPhi;
                        // maxPhi = (Double.isNaN(maxPhi) ||
                        // phi>maxPhi)?phi:maxPhi;
                        //
                        double theta = Math.PI / 2 - colatitude;
                        CoordinateVector v = result.getCoordinateSystem().createCoordinateVector(phi, theta, r);
                        curve.points.add(v);
                    }
                    result.getCurves().add(curve);
                }
            }
            // System.out.println("Min Colatitude: "+minColatitude+" Max Colatitude: "
            // +maxColatitude);
            // System.out.println("Min Phi: "+minPhi+" Max Phi: " +maxPhi);
            // System.out.println("B0: "+b0+", L0: "+l0);
        }
        return result;
    }

}
