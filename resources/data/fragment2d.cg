struct outputStruct {
        float4 color : COLOR;
};

outputStruct main(
        float4 texcoord0 : TEXCOORD0,
        sampler2D texunit0 : TEXUNIT0,
        uniform float truncationValue : C0,
        uniform float isdifference : C1,
        float4 texcoord4 : TEXCOORD4,
        uniform sampler2D differenceImage : TEXUNIT2,
        uniform float4 pixelSizeWeighting : C2,
        uniform float gamma : C3,
        uniform float contrast : C4,
        uniform sampler1D lut1 : TEXUNIT1,
        uniform float alpha : C5)
    {
        outputStruct OUT;
        OUT.color = tex2D(texunit0, texcoord0.xy);

        if(isdifference>0.24 && isdifference<0.27){
                OUT.color.r = OUT.color.r - tex2D(differenceImage, texcoord0.xy).r;
                OUT.color.r = clamp(OUT.color.r,-truncationValue,truncationValue)/truncationValue;
                OUT.color.r = (OUT.color.r + 1.0f)/2.0f;
        } else
        if(isdifference>0.98 && isdifference<1.01){
                OUT.color.r = OUT.color.r - tex2D(differenceImage, texcoord4.xy).r;
                OUT.color.r = clamp(OUT.color.r,-truncationValue,truncationValue)/truncationValue;
                OUT.color.r = (OUT.color.r + 1.0f)/2.0f;
        }


        float unsharpMaskingKernel[3][3] = {
                {1, 2, 1},
                {2, 4, 2},
                {1, 2, 1}
        };
        float3 tmpConvolutionSum = float3(0, 0, 0);
        for(int i=0; i<3; i++)
        {
                for(int j=0; j<3; j++)
                {
                        tmpConvolutionSum += tex2D(texunit0, texcoord0.xy + float2(i-1, j-1) * pixelSizeWeighting.x).rgb
                                * unsharpMaskingKernel[i][j];
                }
        }
        tmpConvolutionSum = (1 + pixelSizeWeighting.z) * OUT.color.rgb
                - pixelSizeWeighting.z * tmpConvolutionSum / 16.0f;
        OUT.color.rgb = saturate(tmpConvolutionSum);

        OUT.color.rgb = pow(OUT.color.rgb, gamma);

        OUT.color.rgb = 0.5f * sign(2.0f * OUT.color.rgb - 1.0f) * pow(abs(2.0f * OUT.color.rgb - 1.0f), pow(1.5f, -contrast)) + 0.5f;

        OUT.color.rgb = tex1D(lut1, OUT.color.r).rgb;

        OUT.color.a = OUT.color.a * alpha;

        float geometryRadius = -length(texcoord0.zw);
        float fadeDisc = smoothstep(-1.0499999523162842, -1.0, geometryRadius);
        float maxPixelValue = max(max(OUT.color.r, OUT.color.g), max(OUT.color.b, 0.001));
        OUT.color.a = OUT.color.a * (fadeDisc + (1-fadeDisc) * pow(maxPixelValue, 1-OUT.color.a));

        return OUT;
}
