struct outputStruct {
    float4 color : COLOR;
};

outputStruct main(
    float4 texcoord0 : TEXCOORD0,
    sampler2D texunit0 : TEXUNIT0,
    float4 texcoord3 : TEXCOORD3,
    uniform float truncationValue : C0,
    uniform float isdifference : C1,
    float4 texcoord4 : TEXCOORD4,
    uniform sampler2D differenceImage : TEXUNIT2,
    uniform float4 pixelSizeWeighting : C2,
    uniform float gamma : C3,
    uniform float contrast : C4,
    uniform sampler1D lut0 : TEXUNIT1,
    uniform float alpha : C5,
    uniform float4 cutOffRadius : C6,
    uniform float4 outerCutOffRadius : C7,
    uniform float phi : C8,
    uniform float theta : C9,
    uniform float differencePhi : C10,
    uniform float differenceTheta : C11)
{
    outputStruct OUT;
    OUT.color = tex2D(texunit0, texcoord0.xy);

if(isdifference>0.24 && isdifference<0.27){
    OUT.color.r = OUT.color.r - tex2D(differenceImage, texcoord0.xy).r;
    OUT.color.r = clamp(OUT.color.r,-truncationValue,truncationValue)/truncationValue;
    OUT.color.r = (OUT.color.r + 1.0f)/2.0f;
} else
if(isdifference>0.98 && isdifference<1.01){
    OUT.color.r = OUT.color.r - tex2D(differenceImage, texcoord4.xy).r;
    OUT.color.r = clamp(OUT.color.r,-truncationValue,truncationValue)/truncationValue;
    OUT.color.r = (OUT.color.r + 1.0f)/2.0f;
}


    float unsharpMaskingKernel[3][3] = {
        {1, 2, 1},
        {2, 4, 2},
        {1, 2, 1}
    };
    float3 tmpConvolutionSum = float3(0, 0, 0);
    for(int i=0; i<3; i++)
    {
        for(int j=0; j<3; j++)
        {
            tmpConvolutionSum += tex2D(texunit0, texcoord0.xy + float2(i-1, j-1) * pixelSizeWeighting.x).rgb
                * unsharpMaskingKernel[i][j];
        }
    }
    tmpConvolutionSum = (1 + pixelSizeWeighting.z) * OUT.color.rgb
        - pixelSizeWeighting.z * tmpConvolutionSum / 16.0f;
    OUT.color.rgb = saturate(tmpConvolutionSum);

    OUT.color.rgb = pow(OUT.color.rgb, gamma);

    OUT.color.rgb = 0.5f * sign(2.0f * OUT.color.rgb - 1.0f) * pow(abs(2.0f * OUT.color.rgb - 1.0f), pow(1.5f, -contrast)) + 0.5f;

    OUT.color.rgb = tex1D(lut0, OUT.color.r).rgb;

    OUT.color.a = OUT.color.a * alpha;

    if(texcoord0.x<0.0||texcoord0.y<0.0||texcoord0.x>1.0||texcoord0.y>1.0) {discard;
    }
float dotpos = dot(texcoord3.xyz, texcoord3.xyz);
    if(dotpos<cutOffRadius.x*cutOffRadius.x ||dotpos>outerCutOffRadius.x*outerCutOffRadius.x ){discard;}
    if((texcoord3.z==0.0 && dotpos<0.99)){      discard;
    }
    float3x3 mat = float3x3( cos(phi), -sin(theta)*sin(phi), -cos(theta)*sin(phi), 0., cos(theta), -sin(theta), sin(phi), cos(phi)*sin(theta), cos(theta)*cos(phi));
    float3 zaxisrot = mul(mat,float3(0.,0.,1.));
    float projectionn = dot(texcoord3.xyz,zaxisrot);
    if((texcoord3.z!=0.0 && projectionn<-0.0)){     discard;
    }


    return OUT;
}
